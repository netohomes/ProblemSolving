# 494. Target Sum

# Problem definition

https://leetcode.com/problems/target-sum/

# Recursive solution

The idea is how many times we can get the target putting - or + in the numbers. This is a brute-force recursive solution. We are trying all the possible branches. Event though this solution works this should be improved easily by adding memoization.

```c++
int solve(int index,int sum,vector<int>& nums){
    if(index==0){
        if(nums[0]==0 && sum==0) return 2;
        if(sum-nums[0]==0) return 1;
        if(sum+nums[0]==0) return 1;
        return 0;
    }

    int add = solve(index-1,sum+nums[index],nums);
    int sub = solve(index-1,sum-nums[index],nums);
    return add+sub;
}

int findTargetSumWays(vector<int>& nums, int target) {
    return solve(nums.size()-1,target,nums);
}
```

# Recursive solution with memoization

Important note: when doing memoization check on how many the variales de result depends on. In this case depends on the index and the sum parameters. That is why I needed to use an unordered_map with a pair as key.

Just to note, the memoization reduced the execution time from 411 ms to 151 ms from previous solution.

```C++
struct PairHash {
    // A functor!! A function that is an object
    size_t operator()(const pair<int,int>& p) const {
        auto h1 = std::hash<int>{}(p.first);
        auto h2 = std::hash<int>{}(p.second);
        return h1 ^ (h2 << 1);
    }
};

class Solution {
public:

    int solve(int index, int sum, vector<int>& nums, unordered_map<pair<int,int>, int, PairHash>& memo) {
        if (memo.find(make_pair(index,sum)) != memo.end()) {
            return memo[make_pair(index,sum)];
        }
        int res = 0;
        if (index == 0){
            if (nums[0] == 0 && sum == 0) res = 2;
            else if (sum - nums[0] == 0) res = 1;
            else if (sum + nums[0] == 0) res = 1;
        } else {
            int add = solve(index-1, sum+nums[index], nums, memo);
            int sub = solve(index-1, sum-nums[index], nums, memo);
            res = add + sub;
        }
        memo[make_pair(index,sum)] = res;
        return res;
    }

    int findTargetSumWays(vector<int>& nums, int target) {
        unordered_map<pair<int,int>, int, PairHash> memo;
        int res = solve(nums.size()-1, target, nums, memo);
        return res;
    }
};
```

The same approach but cleaner:

```C++
class Solution {
public:

    int solve(int index, int target, vector<int>& nums, unordered_map<pair<int,int>, int, PairHash>& memo, int currSum) {
        if (memo.find(make_pair(index,currSum)) != memo.end()) {
            return memo[make_pair(index,currSum)];
        }

        if (index < 0 && currSum == target) {
            return 1;
        }
        if (index < 0) {
            return 0;
        }

        int add = solve(index-1, target, nums, memo, currSum + nums[index]);
        int sub = solve(index-1, target, nums, memo, currSum - nums[index]);

        memo[make_pair(index,currSum)] = add + sub;
        return memo[make_pair(index,currSum)];
    }

    int findTargetSumWays(vector<int>& nums, int target) {
        unordered_map<pair<int,int>, int, PairHash> memo;
        return solve(nums.size()-1, target, nums, memo, 0);
    }
};
```

According to some readings the previous solution is considered like DP, the top-down approach. So can we say that DP is just recursion + memoization??

# DP solution
